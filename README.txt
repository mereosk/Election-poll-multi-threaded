Τμήμα Πληροφορικής και Τηλεπικοινωνιών
Κωνσταντίνος Μερεός sdi1700085
Προγραμματισμός Συστήματος
Εργασία 2

Abstract (or something like that)

Επειδή μου βγήκε λίγο εκτενές το readme θα κάνω μια μικρή περίληψη της κάθε παραγράφου με μερικά σχόλια
1η παρ -> Διάφοροι φάκελοι του προγράμματός μου και τι περιέχουν από αρχεία.
2η παρ -> Makefile και διάφοροι τρόποι εκτέλεσης του προγράμματός μου. (σημαντικό)
3η παρ -> Εξήγηση των δύο map και επισήμανση του ότι η main του poller είναι το master thread.
4η παρ -> Περιγράφω την ουρά buffer και αναλύω λίγο την αποφυγή του busy waiting στο master thread.
5η παρ -> Ανάλυση των νημάτων workers, αποφυγή busy waiting, αποφυγή race conds με mutexes.
6η/7η/8η παρ -> Εξήγηση του πώς όταν πατάω SIGINT στο poller τερματίζουν σωστά οι workers και τελειώνει το πρόγραμμά μου.
9η παρ -> Περιγραφή του pollSwayer, του vector που αποθηκεύει τα pthreadId's κα
10η παρ -> Το πρόγραμμά μου δέχεται ονόματα και κόμματα μέχρι 64ων χαρακτήρων για να έχει φυσιολογική συμπεριφορά.

Όσο αφορά τα script αρχεία μου έχουν πολλά σχόλια και πιστεύω πώς δεν χρειάζεται να σας σπαταλήσω το χρόνο σας με περεταίρω
εξηγήσεις.

Execution and Separate Compilation

To πρόγραμμά μου αποτελείται από 5 directories το include, misc, modules, program και scripts. Στο φάκελο program υπάρχουν
τα κύρια προγράμματα, poller.c και pollSwayer.c. Στη συνέχεια στο φάκελο modules υπάρχει το αρχείο helpingFuncs.c το οποίο
εμπεριέχει βοηθητικές συναρτήσεις στα παραπάνω προγράμματα όπως, σωστό διάβασμα από socket, τσεκάρισμα των argument των προ-
γραμμάτων και άλλα. Έπειτα στο modules έχω τα αρχείο ADTList.c, ADTMap.c, ADTVector.c kai ADTQueue.c. Τα προηγούμενα είναι, 
αντίστοιχα, υλοποιήσεις λίστας, πίνακα κατακερματισμού, δυναμικός πίνακας καθώς και μια ουρά η οποία υλοποιήθηκε με τη βοήθεια
της λίστας. Να τονίσω ότι οι υλοποιήσεις των προηγούμενων δομών είναι "εμπνευσμένες" από τις δομές
του κ.Χατζηκοκολάκη το 2020. Έχουν γίνει φυσικά αρκετές αλλαγές, αλλά εφόσον μπορούσαμε να χρησιμοποιήσουμε STL για τη C++ δεν
έφτιαξα από την αρχή δομές. Επίσης να τονίσω ότι είχα ρωτήσει στο μάθημα για αυτό και μου είχατε πει ότι δεν πειράζει αν ήταν 
μόνο οι δομές. Φυσικά όλες οι αρχικοποιήσεις των συναρτήσεων που υπάρχουν μέσα στα αρχεία που μόλις περιέγραψα βρίσκονται 
στο φάκελο include σε αντίστοιχα αρχεία .h. Φυσικά, στο φάκελο scripts υπάρχουν τα τρία scriptάκια που μας ζητήσατε createInput.sh
(άλλαξα το όνομα σε camelcase), processLogFile.sh και tallyVotes.sh. Υπάρχει, βέβαια, και το myCreateInput.sh το οποίο κάνει
μία δουλειά την οποία δεν ζητήσατε αλλά με βοήθησε στο debugging και το άφησα. Στο φάκελο misc υπάρχουν πολλά text αρχεία που
βοηθάνε στο πρόγραμμα και κρατάνε τα αποτελέσματα (θα τα περιγράψω παρακάτω). Όλα τα αρχεία είναι .txt (το τονίζω γιατί δεν
το είχατε ζητήσει). 

Τέλος υπάρχει το Makefile (βρίσκεται εκτός των directories που περιέγραψα) το οποίο με τη χρήση make μεταγλωττίζει τα προγράμματά 
μου. Για την εκτέλεση χρησιμοποιώ τις εντολές make server και σε διαφορετικό παράθυρο(ή μηχάνημα) make client. Τα arguments
για το server είναι στη μεταβλητή ARGSSERVER του Makefile και για τον client στη ARGSCLIENT. Στη προηγούμενη θα πρέπει να 
αλλάξετε οπωσδήποτε το πρώτο argument με το hostname του μηχανήματός σας. Επίσης υπάρχουν και οι εντολές make valserver και
make valclient για να εκτελεστούν τα προγράμματα με τον valgrind debugger για να δείτε για τυχόν leaks ή errors. Επιπροσθέτως 
υπάρχει το make clean που διαγράφει όλα τα αντικειμενικά αλλά και εκτελέσιμα αρχεία του προγράμματος. Παρακάτω παραθέτω 
διάφορα παραδείγματα εκτέλεσης των προγραμμάτων μου:

1) Για να τρέξω το πρόγραμμα όπως ζητήθηκε
    ~ Εκτελώ (μέσα στο φάκελο scripts)
      ./createInput.sh ../misc/politicalParties.txt 100
    ~ Έχω 2 παράθυρα ανοιχτά στον εξωτερικό φάκελο, στο ένα κάνω make server έπειτα στο άλλο make client. Στη συνέχεια πατάω 
      CTRL-C στο παράθυρο του server.
    ~ Εκτελώ (μέσα στο φάκελο scripts)
      ./tallyVotes.sh ../misc/tallyResultsFile.txt
    ~ Εκτελώ (μέσα στο φάκελο scripts)
      ./processLogFile.sh ../misc/pollerResultsFile.txt
    ~ Εκτελώ (μέσα στο φάκελο misc)
      diff pollerResultsFile.txt tallyResultsFile.txt 
      και βλέπω ότι δεν υπάρχει διαφορά
    ~ Εκτελώ (μέσα στο φάκελο misc)
      diff pollerResultsFile.txt tallyResultsFile.txt 
      και βλέπω ότι δεν υπάρχει διαφορά
    ~ Εκτελώ (μέσα στο φάκελο misc)
      sort poll-stats.txt > 1.txt ; diff tallyResultsFile.txt 1.txt ;diff pollerResultsFile.txt 1.txt
      Το οποίο βγάζει κάτι του τύπου
      0a1
      > 100 total_number_of_votes
      0a1
      > 100 total_number_of_votes
      Με το παραπάνω βλέπω ότι η μόνη διαφορά του sorted poll-stats είναι η τελευταία γραμμή που γράφει τον αρι-
      θμό των ψήφων, το οποίο είναι το επιθυμητό αποτέλεσμα. Τέλος δεν ξεχνάω να διαγράψω το 1.txt

2) Για να τρέξω το test case αρχείο που μας δώσατε το οποίο είναι το /misc/inputFileTCase.txt:
    ~ Αλλάζω το τρίτο argument του client (Makefile->ARGSCLIENT από $(MISC)/inputFile.txt σε $(MISC)/inputFileTCase.txt)
    ~ Έχω 2 παράθυρα ανοιχτά στον εξωτερικό φάκελο, στο ένα κάνω make server έπειτα στο άλλο make client. Στη συνέχεια πατάω 
      CTRL-C στο παράθυρο του server.
    ~ Αλλάζω, στο αρχείο /scripts/tallyVotes.sh, τη τέταρτη γραμμή από ".../inputFile.txt" σε ".../inputFileTCase.txt"
    ~ Εκτελώ (μέσα στο φάκελο scripts)
      ./tallyVotes.sh ../misc/tallyResultsFile.txt
    ~ Εκτελώ (μέσα στο φάκελο scripts)
      ./processLogFile.sh ../misc/pollerResultsFile.txt
      Πρέπει να βρίσκομαι στο φάκελο scripts γιατί το η μεταβλητή έχει την τιμή ../misc/etc οπότε δεν θα βρίσκει το αρχείο
    ~ Εκτελώ (μέσα στο φάκελο misc)
      diff pollerResultsFile.txt tallyResultsFile.txt 
      και βλέπω ότι δεν υπάρχει διαφορά
    ~ Εκτελώ (μέσα στο φάκελο misc)
      sort poll-stats.txt > 1.txt ; diff tallyResultsFile.txt 1.txt ;diff pollerResultsFile.txt 1.txt
      Το οποίο βγάζει κάτι του τύπου
      0a1
      > 49 total_number_of_votes
      0a1
      > 49 total_number_of_votes
      Με το παραπάνω βλέπω ότι η μόνη διαφορά του sorted poll-stats είναι η τελευταία γραμμή που γράφει τον αρι-
      θμό των ψήφων, το οποίο είναι το επιθυμητό αποτέλεσμα. Τέλος δεν ξεχνάω να διαγράψω το 1.txt

3) Υπάρχει και ένας τρίτος τρόπος και έχει να κάνει με το αρχείο myCreateInput.sh που έφτιαξα και διαφοροποιεί
   λίγο τα δεδομένα που παράγονται στο inputFile.txt. Συγκεκριμένα αντίνα τρέξω το
   ./createInput.sh ../misc/politicalParties.txt 100
   Εκτελώ το
   ./myCreateInput.sh ../misc/politicalParties.txt 100
   Αυτό έχει ως αποτέλεσμα αντί για τυχαίες συμβολοσειρές για όνομα και επίθετο να είναι πραγματικά ελληνικά
   ονόματα τα οποία αντλέι το script από τα αρχεία greekNames.txt και greekSurnames.txt. Στη συνέχεια είναι όλα 
   ίδια με το (1).

Poller

To poller πρόγραμμα ουσιαστικά υλοποιεί έναν πολυνηματικό TCP server ο οποίος επικοινωνεί πολλούς πελάτες ταυτόχρονα.
Έχει δύο Map τα οποία υλοποιήθηκαν μέσω Hash Table με open addressing. Το ένα, ονομάζεται statsMap, κρατάει
σαν key το όνομα του κόμματος και σαν value τις φορές που κάποιος ψήφισε το κόμμα. Όταν πατηθεί το SIGINT τότε στο
τέλος γράφει αυτές τις τιμές στο αρχείο poll-stats.txt μαζί με μια global τιμή tatalVotes. To άλλο map, checkMap
κρατάει σαν key και value το όνομα ενός ψηφοφόρου αλλά δεν κρατάει duplicates. Έτσι μπορώ να βλέπω αν ένας ψηφοφόρος
έχει ψηφίσει ξανά. Στη συνέχεια, αφού γίνονται οι κατάλληλες αρχικοποιήσεις αλλά και αφού φτιάξω τα threads που μου
υπαγορεύει η τιμή από τα arguments υλοποίησα ένα ατέρμονο loop το οποίο δέχεται συνεχώς συνδέσεις (θα εξηγήσω μετά 
πώς βγαίνω από το loop με τη βοήθεια του siging). Να προσθέσω ότι υλοποίησατη main του poller σαν master thread και 
δεν έφτιαξα άλλο thread για το σκοπό αυτό.

Η επόμενη δομή που βλέπω είναι μία ουρά η οποία είναι και ο buffer του προγράμματός μου, ο οποίος δέχεται sockets ως
δεδομένα. Έτσι στο master thread μου, όταν γίνεται το accept και παίρνω το socket το προσθέτω στην ουρά. Αλλά πρώτα
ελέγχω αν η ουρά είναι γεμάτη (queue_full). Για να μην γίνει όμως busy waiting περιμένω στην condition variable
cond_nonfull κλείνοντας τα όλα αυτά με τον mutex mtx, λόγω του ότι όλες οι δομές είναι στο heap και όλα τα threads
έχουν πρόσβαση σε αυτές. Αφού, λοιπόν, προσθέσω το socket στην ουρά εκτελώ ένα signal στην cond variable cond_nonempty,
ώστε αν περιμένει κάποιος worker σε άδειο buffer να του ανατεθεί δουλειά.

O worker εκτελεί και αυτός ένα ατέρμονο loop (πάλι θα εξηγήσω πώς βγαίνει από αυτό). Στην αρχή περιμένει αν ο buffer
είναι άδειος, χωρίς busy waiting, στη cond var cond_nonempty. Τραβάει το πρώτο στοιχείο (socket) της ουράς και ενη-
μερώνει με signal το master thread, ώστε να μην περιμένει σε γεμάτο buffer , στη μεταβλητή cond_nonfull. Στη συνέχεια,
ξεκινάει η ενδοεπικοινωνία μεταξύ worker και client. Μερικά πράγματα που πρέπει να αναφέρω είναι ότι, ότι ο client
στέλνει το όνομα βλέπω αν είναι duplicate sto checkMap και αν δεν είναι το προσθέτω. Αυτή η δουλειά πρέπει να είναι 
πλαισιωμένη από το mutex checkMapMtx, διότι βρίσκεται στο heap. Αντίστοιχα όταν, παρακάτω, παίρνω το party όνομα πρέ-
πει, αν δεν υπάρχει στο statsMap να το προσθέσω αλλιώς να αυξήσω το value κατά 1. Όλα αυτά γίνονται αφού κλειδώσω το 
mutex statsMapMtx. Τέλος για να γράψω τη γραμμή name surname party στο poll-log.txt αρχείο κλειδώνω το mutex writeMtx,
ώστε να τα δεδομένα να γραφτούν σωστά στο αρχείο.

SIGINT to gracefully terminate the program

Στον poller ένα πολύ σημαντικό στοιχεί ο είναι το πώς τερματίζει το μέσω του SIGINT. Αρχικά στο master thread(main) 
εκτελώ την συνάρτηση assignHandler η οποία μέσω της sigaction όποτε 'δει' ctrl-c εκτελεί τη συνάρτηση catchInterupt.
Έπειτα, πριν φτιαχτούν όλα τα threads κάνω block το σήμα από όλα τα threads με τη βοήθεια της pthread_sigmask. Αφού
φτιαχτούν, το κάνω unblock στο master thread (main), ώστε να μόνο αυτό να χειριστεί το σήμα. 

Έτσι, όταν το poller λάβει CTRL-C εκτελεί τη συνάρτηση catchInterupt η οποία αλλάζει τη σημαία sigintFlag σε true 
και εκτελεί ένα broadcast στη cond var cond_nonempty, ώστε να ενημερώσει όλα τα threads ότι πρέπει να κάνουν return
και να βγούνε από την ατέρμονη επανάληψη. Έτσι, όσα worker threads περιμένουν στο pthrad_cond_wait θα ξυπνήσουν, θα
δουν ότι άλλαξε η σημαία και θα τερματίσουν. Αλλά και όσα δεν περιμένουν, με το που τελειώσουν θα μπουν στο non busy
waiting loop και το πρώτο πράγμα που θα τσεκάρουν θα είναι αν έχει αλλάξει η σημαίαν και θα τερματίσουν. 

Στο master thread, όταν γίνει SIGINT θα επιστρέψει η accept errno=EINTR, μόνο τότε βγαίνω από το ατέρμονο loop. Έξω από
αυτό περιμένω όλα τα threads να τελειώσουν ομαλά, γράφω στο αρχείο poll-stats.txt και κάνω τα κατάλληλα free.

pollSwayer

Το pollSwayer πρόγραμμα ουσιαστικά υλοποιεί έναν πολυνηματικό πελάτη ο οποίος επικοινωνεί με έναν server. Εδώ τα threads
είναι ακαθόριστου μεγέθους οπότε χρησιμοποιώ ένα vector για να με βοηθήσει με τα create και join των threads. Έτσι, έπειτα
από διάφορες αρχικοιποιήσεις στη main, διαβάζω το inputFile, και για κάθε γραμμή φτιάχνω ένα thread και του περνάω σαν όρι-
σμα ένα struct threadInfo το οποίο περιέχει το threadId αλλά και τη γραμμή την οποία θα επικοινωνήσει με το server. Στη 
συνέχεια προσθέτω το thread info που φτιάχτηκε στο vector μου. Αφού τελειώσουν τη δουλειά τους τα νήματα, τα περιμένω 
εκτελώντας pthread_join για όλα τα threads που έχουν αποθηκευτεί στο vector μου. Όσο αφορά τα threads , πρώτα χωρίζουν τη 
γραμμή που πήρανε μέσω τα ορίσματα σε name και party και έπειτα φτιάχνουν το socket που θα επικοινωνήσει με το server. 
Στη συνέχεια, ακολουθεί η επικοινωνία με το server την οποία δεν θα αναλύσω.

read_socket

Μία σημαντική συνάρτηση του προγράμματός μου είναι η read_socket η οποία διαβάζει δεδομένα από ένα socket. Ένα πράγμα που
πρέπει να υπογραμμίζω, είναι ότι είναι σωστή για ονόματα και κόμματα κάτω των 64 χαρακτήρων. Μετά το πρόγραμμά μου έχει
τυχαία συμπεριφορά. Αυτό θα το διορθώσω μετέπειτα αλλά τώρα δεν προλαβαίνω μέσα στην εξεταστική μέσα. Κατά τα άλλα, η 
read διαβάζει μέσω σε ένα while loop, ώστε να αποφευχθούν τα διάφορα προβλήματα που τη διέπουν σαν εντολή.

Ευχαριστώ πολύ για την υπομονή και το χρόνο σας, καλό καλοκαίρι!